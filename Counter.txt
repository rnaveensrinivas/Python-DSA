Counter - https://docs.python.org/3/library/collections.html#collections.Counter

-> subclass of dict - only hashable objects
-> count can be negative also.
-> dict - preservers order; so does Counter - remembers insertion order. math operations also preserver order(left operand first and then right)

>>> c = Counter()                           # O(1) - a new, empty counter
>>> c = Counter('gallahad')                 # O(n) - a new counter from an iterable
>>> c = Counter({'red': 4, 'blue': 2})      # O(n) - a new counter from a mapping
>>> c = Counter(cats=4, dogs=8)             # O(n) - a new counter from keyword args
>>> c = Counter(['eggs', 'ham'])	    # O(n) 
>>> c['bacon']                              # O(1) - count of a missing element is zero
>>> c['sausage'] = 0                        # O(1) - counter entry with a zero count
>>> del c['sausage']                        # O(1) - del actually removes the entry


Methods - 
--> update(iterable) # O(n)  updates the count object 
--> elements() # O(n) returns iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an elementâ€™s count is less than one, elements() will ignore it.

>>> c = Counter(a=4, b=2, c=0, d=-2)
>>> sorted(c.elements()) # O(nlogn)
['a', 'a', 'a', 'a', 'b', 'b']

---- ---- ---- ----
--> most_common([n]) #O(nlogn) - Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered:

>>> Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]

---- ---- ---- ----
--> subtract([iterable-or-mapping]) - # O(n) subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative.

>>> c = Counter(a=4, b=2, c=0, d=-2) 	# O(n) 
>>> d = Counter(a=1, b=2, c=3, d=4)	# O(n) 
>>> c.subtract(d)			# O(n) 
>>> c					
Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})

---- ---- ---- ----
--> total() - # O(n) Compute the sum of the counts. 

>>> c = Counter(a=10, b=5, c=0)		# O(n) 
>>> c.total()				# O(n) 
15

---- ---- ---- ----
Counters support rich comparison operators for equality, subset, and superset relationships: ==, !=, <, <=, >, >=. All of those tests treat missing elements as having zero counts so that Counter(a=1) == Counter(a=1, b=0) returns true.

>>> c.total()                       # O(n) - total of all counts
>>> c.clear()                       # O(n) - reset all counts
>>> list(c)                         # O(n) - list unique elements
>>> set(c)                          # O(n) - convert to a set
>>> dict(c)                         # O(n) - convert to a regular dictionary
>>> c.items()                       # O(n) - access the (elem, cnt) pairs
>>> Counter(dict(list_of_pairs))    # O(n) - convert from a list of (elem, cnt) pairs
>>> c.most_common()[:-n-1:-1]       # O(nlogn) - n least common elements
>>> +c                              # O(n) - remove zero and negative counts

---- ---- ---- ----
Below all are O(n) 

>>> c = Counter(a=3, b=1)
>>> d = Counter(a=1, b=2)
>>> c + d                       # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
>>> c - d                       # subtract (keeping only positive counts)
Counter({'a': 2})
>>> c & d                       # intersection:  min(c[x], d[x])
Counter({'a': 1, 'b': 1})
>>> c | d                       # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})
>>> c == d                      # equality:  c[x] == d[x]
False
>>> c <= d                      # inclusion:  c[x] <= d[x]
False

---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
